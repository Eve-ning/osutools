#' A model that detects manipulatability in charts
#'
#' @description Manipulation is where certain notes can be played in an
#' incorrect order while still maintaining a good accuracy and judgement.
#'
#' This model aims to look at notes forward of each other and calculates a value
#' called a bias.
#'
#' Biases are how the chart decides to favor a specific column over the other by
#' having higher or lower density.
#'
#' The higher the bias, the less manipulatable it'll be
#'
#' @param chart chart generated by chartParse
#' @param window The window to check for biases.
#' @param bias.scale Scales the variances
#' @param bias.correction Corrects 0 variances by adding a small value
#' @param bias.power The lower the value, the less of a correction
#' @param ignore.types Types to be ignored during model creation
#'
#' @importFrom magrittr %<>% %>% set_colnames
#' @importFrom dplyr filter mutate group_by summarise
#' @importFrom rlang .data
#' @importFrom reshape2 melt
#' @importFrom stats var
#'
#' @export

model.manipulation <- function(chart,
                               window = 1000,
                               bias.scale = 0.25,
                               bias.correction = 1.1,
                               bias.power = 0.1,
                               ignore.types = c('lnotel')){

  if (bias.scale < 0) {
    stop("bias.scale cannot be less than 0")
  } else if (bias.correction <= 1) {
    stop("bias.correction cannot be <= 1, it will cause some values to be 0")
  }

  unq.offsets <- unique(chart$offsets)

  # We assign all types the value of 1 as their weight excluding
  # ignore.types
  chart %<>%
    dplyr::filter(!(.data$types %in% ignore.types)) %>%
    dplyr::mutate(types = 1)
  chart %<>%
    split(chart$keys, drop = T)

  # The idea of a window is so that we can find biases on columns
  # If the bias is high, the variance will be high, so it's less
  # manipulatable
  chart.count <- as.data.frame(.cppModelManipulation(unq.offsets,
                                                     chart,
                                                     window = window,
                                                     is_sorted = F))


  chart.keys <- ncol(chart.count)

  # This dulplicates chart.count and shifts all records by 1 upwards
  chart.count.shifted <- rbind(chart.count[2:nrow(chart.count),], NA)

  # This gets the difference between the 2 counts
  chart.count.diff <-
    chart.count.shifted[,2:chart.keys] - chart.count[,2:chart.keys]

  chart.count <- chart.count[,1] %>%
    # Bind with the diff
    cbind(chart.count.diff) %>%
    # This sets the names
    magrittr::set_colnames(c("offsets", 1:(ncol(chart.count) - 1))) %>%
    reshape2::melt(id.vars = 1, variable.name = "keys", value.name = "counts") %>%
    dplyr::mutate(counts = abs(.data$counts)) %>%
    dplyr::group_by(.data$offsets) %>%
    # Essentially 1 / (Sum ** Power + 1)
    # + 1 is so that the value doesn't jump above 1.0 this helps it go in line
    # with other keys
    dplyr::summarise(values = sum(.data$counts)) %>%
    dplyr::mutate(
      values = (1/(-.data$values * bias.scale - bias.correction) + 1) ** bias.power)

  return(chart.count)
}
