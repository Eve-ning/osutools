#' For each row, gets the time before the next key
#'
#' This will not overwrite the current columns,
#' it will generate a separate one.
#'
#' @param chart The data.frame generated by f.chart.parse
#' @param ignore.types A character vector determining what
#' types of notes should be ignored
#'
#' @importFrom magrittr %>%
#' @importFrom dplyr mutate filter arrange rename desc
#' @importFrom reshape2 dcast melt
#' @importFrom rlang .data
#' @export

diffBroadcast <- function(chart,
                          ignore.types = c('lnotel')){

  # Drop NA rows
  chart.bcst <- chart %>%

  # Ignores any types that matches the list
    dplyr::filter(!(.data$types %in% ignore.types)) %>%

    # As per the cpp function's requirements, the types
    # that we would want to participate is TRUE, while
    # the spectators are FALSE
    dplyr::mutate(types = T) %>%

  # Cast keys to longer table.
    reshape2::dcast(offsets ~ keys,
                    value.var = 'types', fill = F) %>%

  # The plan is to flip the chart up-side down, then
  # we track different columns on the accumulated
  # offsets.
    dplyr::arrange(dplyr::desc(.data$offsets))

  # Broadcast with cpp and assign back to the [2:] columns
  reset.columns <- 2:ncol(chart.bcst)
  chart.bcst[,reset.columns] <-
    .cppBroadcast(chart.bcst$offsets,
                  as.matrix(chart.bcst[,reset.columns]))

  chart.bcst %<>%
    # Merge to get back original type data
    merge(chart, by = 'offsets') %>%

    # Melt bcst columns to diffs
    reshape2::melt(measure.vars = 2:ncol(chart.bcst),
                   variable.name = 'keys.tos',
                   value.name = 'diffs',
                   na.rm = T) %>%

    # Rename for clarity
    dplyr::rename(keys.froms = .data$keys) %>%

    # Coerce to numeric
    dplyr::mutate(keys.tos = as.numeric(.data$keys.tos)) %>%

    # Remove invalid diffs
    dplyr::filter(.data$diffs > 0)

  return(chart.bcst)
}
